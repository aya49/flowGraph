---
title: "_**flowGraph**_: Identifying differential cell populations in flow cytometry data accounting for marker frequency"
shorttitle: "flowGraph"
author: Alice Yue
email: aya43@sfu.ca
package: flowGraph
date: September 2020
output: 
    BiocStyle::html_document
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{flowGraph}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# License

Artistic-3.0

```{r style, echo=FALSE, results='asis'}
BiocStyle::markdown()
```

# Installing the package

**flowGraph** can be downloaded from "https://github.com/aya49/flowGraph" or 
cloned from "https://github.com/aya49/flowGraph.git" and installed locally.

You can also intall it directly from Github using BiocManager:

```{r, eval=FALSE, label=library1, warning=FALSE, message=FALSE, echo=TRUE, fig=FALSE, results='hide'}
if (!require("BiocManager")) install.packages('BiocManager') 
BiocManager::install("aya49/flowGraph")
```


# Introduction

**flowGraph** contains functions to analyze the space of all possible 
(overlapping) cell populations in one or more flow cytometry samples, 
given cell counts from a Phenotype object generated by the `flowType` package.

```{r, label=library2, warning=FALSE, message=FALSE, echo=TRUE, fig=FALSE, message=FALSE}
library(flowGraph)
library(flowType)
```

The main goal of _**flowGraph**_ is to help users interpret which cell populations 
are differential between samples of different etiologies. To understand how 
flowGraph defines cell populations, we introduce the cell hierarchy model below.
This model will serve as the basis for the analysis done in the 
_**flowGraph**_ package.

A **cell hierarchy** is a directed acyclic graph that maps out all possible 
cell populations. In this graph, each cell population is a node while relations 
between cell populations are represented by edges. Each node is labelled by 
whether or not its corresponding cell population contains cells that does/not 
contain a subset of markers. For example, if the markers used in an experiment 
is $A$, $B$, $C$, $D$, then $A^-$ and $A^+$ would represent the cell population 
with cells that does/not contain marker $A$ (e.g. Figure \ref{fig:ch}). 
flowType then provides the cell count for each of these cell populations as 
input into _**flowGraph**_.

```{r, message=FALSE}
no_cores <- 1
data(fg_data_pos15)
fg <- flowGraph(fg_data_pos15$count, meta=fg_data_pos15$meta,
                prop=FALSE, specenr=FALSE, normalize=FALSE, no_cores=no_cores)
gr <- fg_get_graph(fg)
gr <- ggdf(gr)
gr$v$colour <- ifelse(!grepl("[-]",gr$v$phenotype), 1,0)
                     # "nodes with only marker conditions", "other nodes")
gr$v$label <- gr$v$phenotype
gr$v$v_ind <- gr$v$label_ind <- TRUE
gr$e$e_ind <- !grepl("[-]",gr$e$from) & !grepl("[-]",gr$e$to)
```
```{r, fig.wide=TRUE}
knitr::opts_template$set(figure1=list(fig.height=9, fig.width=9))
plot_gr(gr, main="Example cell hierarchy with markers A, B, C, D")
```


Traditionally, cell populations are quantified by their proportion, or their 
cell count over the total cell count. A downside to this analysis is that if 
one cell population is differential, then all cell populations that contain 
cells that are also in that differential cell population would also be flagged 
as significantly differential. By incorporating information on relations 
between cell populations, _**flowGraph**_ uses the notion of 
expected proportions and **SpecEnr** or specific enrichment as a replacement 
for proportions to isolate only differential cell populations.


# Workflow: a simple example

This section will run through a simple example of how _**flowGraph**_ can be 
used to analyze a set of flow cytometry samples.

Typically, one would input a sample x cell population matrix and 
a directory where one wants to save all of the flowGraph resuts and plots:

```{r, eval=FALSE}
no_cores <- 1 # number of cores to parallelize on.
data(fg_data_pos15)
fg <- flowGraph(
    fg_data_pos15$count, # sample x cell population matrix
    class=fg_data_pos15$meta$class, # a vector indicating each sample's class
    path="flowGraph_example", # a directory for flowGraph to output results to
    no_cores=no_cores) # number of cores to use, typically 1 for small data
```

The flowGraph output can be loaded into R from the specified directory as 
a flowGraph object `fg`. 

```{r, eval=FALSE}
fg <- fg_load("flowGraph_example")
```

This flowGraph object can be further analyzed and
modified by using methods described in the following sections.


## Data sets contained in the package

The package contains two data sets:
- `fg_data_fca` [@aghaeepour2013critical]: a real data set comparing healthy 
and AML (acute myeloid leukemia) positive subjects; it is known that there is 
an outlier sample and that cell population node $CD34^+$ increases in production 
in the AML positive subjects' samples.
- `fg_data_pos15`: a positive control data set where cell population node 
   $A^{+}B^{+}C^+$ is artificially increased by 50\%.
- `fg_data_pos30`: a positive control data set where cell population node 
   $A^{+...}B^{+...}C^+$ is artificially increased by 50\%. Note this data set 
   contains multiple thresholds for markers $A$ and $B$.


Both of these are lists containing elements:
- `count`: a sample x cell population numeric matrix containing cell count data.
- `meta`: a data frame containing meta data on the samples in `count`. 
   The sample names in the `id` corresponds with the row names in `count`.

```{r,label=Load_Data, fig=FALSE, message=FALSE}
# data(fg_data_fca)
data(fg_data_pos15)
# data(fg_data_pos30)

# ?fg_data_fca
# ?fg_data_pos15
# ?fg_data_pos30
```


## Initializing a flowGraph object

To contain information regarding cell population quantification and the 
cell hierarchy structure in one place, we use a **flowGraph** object to conduct 
analysis. To initialize a flowGraph object, the user can give as input, 
a numeric vector, matrix, Phenotype object (from the flowType package), 
a list of `Phenotypes` objects, or a vector contining full paths to 
`load()`-able `Phenotypes` objects. For examples on how all of these options 
can be used, see `?flowGraph`. 

See Appendix 1 or the flowType package vignette for an example of how to 
generate `Phenotypes` objects starting from raw FCS files.

For our example, we will directly use a numeric matrix as provided by our 
`fg_data_pos15` data set. By default, `flowGraph` will calculate all of the 
proportion `prop`, SpecEnr `specenr`, and normalized count `normalize` features.
If you do not want any of these to be calculated, set the corresponding 
parameters to `FALSE` as we did to `normalize` below.


```{r, message=FALSE}
# no_cores <- 1 # number of cores to parallelize on.
data(fg_data_pos15)
fg <- flowGraph(fg_data_pos15$count, class=fg_data_pos15$meta$class, 
                no_cores=no_cores, normalize=FALSE)
# fg <- flowGraph(fg_data_pos15$count, meta=fg_data_pos15$meta, class="class"
#                 no_cores=no_cores, prop=TRUE, specenr=TRUE, normalize=FALSE)
```

By default, `calculate_summary` is set to `TRUE` so that a default set of
summary statistics will be calculated for the SpecEnr
node feature and `prop` edge feature. Note that if the user decides to do this,
the `class` parameter must also be a vector the same length as the given number of
samples OR be set to the column name of column containing
the class label the user wishes to analyze. We recommend the former.
In the latter case, by default, we assume this column is named `class`.
A class in this context is, for example, an experiment or control sample.
If the user does not wish for this to be calculated during construction
of the flowGraph object, the user can set `calculate_summary` to `FALSE` in the
`flowGraph` function.

A note that in the above example, we provided the `flowGraph` object constructur 
with a `class` or a class vector the same length as our input indicating the 
class labels of each sample. This vector will be put into a `meta` data frame
inside the flowGraph object where its column is named `class`.

If the user has a specific meta he/should like to use, the user can also input
`meta` or the sample meta data directly (commented out above). 
If the user did not provide a sample meta data, this
can be given at a later time. Just make sure the meta data is a data frame
containing a `id` column where its values correspond to the row names in 
the flowGraph objects' feature matrices.

```{r}
meta <- fg_get_meta(fg)
head(meta)

mcount <- fg_get_feature(fg, "node", "count")
head(rownames(mcount))
```


## Retrieving results from a flowGraph object

The default summary statistics is calculated using the Wilcoxan signed-rank test and adjusted
using the `byLayer` adjustment method. This adjustment method is a family-wise method that 
multiplies the p-value for each cell population by the number of nodes in 
its layer and the total number of layers in the cell hierarchy on which there 
exists a cell population node.

Below, we retrieve this summary statistic and list out the cell
populations with the most significant p-values as per below.

```{r}
# get feature descriptions
fg_get_summary_desc(fg)
# get a summary statistic
fg_sum <- fg_get_summary(fg, type="node", summary_meta=list(
    feature="SpecEnr", test_name="t_diminish", 
    class="class", label1="exp", label2="control"))
# fg_sum <- fg_get_summary(fg, type="node", index=1) # same as above

# list most significant cell populations
p <- fg_sum$values # p values
head(sort(p),30)
```

To make changes to the flowGraph object, see functions that start with `fg_`.

Once we have made all the changes necessary, we can save the flowGraph object to
a folder. Inside the folder, all the feature values and summary statistics
are saved as csv files. Plots for each summary statistic can also optionally 
be saved to this folder.

The same folder directory is used to load the flowGraph object when needed again.

```{r}
# fg_save(fg, "path/to/user/specified/folder/directory") # save flowGraph object
# fg <- fg_load("path/to/user/specified/folder/directory") # load flowGraph object
```

See other flowGraph object initialization options in the Appendix 2.

The following sections will go over additional options for summary statistics,
and result interpretation.


# Accessing and modifying data in a flowGraph object


## Flow cytometry sample meta data

The flowGraph object initially contains meta data on the samples and 
cell population nodes (phenotypes). The most basic way of understanding what 
is inside a flowGraph object is by using `show`. This shows a description of 
the flowGraph object and returns a list of data frames containing information 
on the node and edge features and the summary statitics performed on them 
shortly in this vignette.

```{r}
show(fg)
```

One can obtain meta data on samples and cell populations as follows. 
Note that information on cell populations is given to the user in the form of a 
`graph` or a list contianing data frames `v` and `e`. The former represents the 
nodes or the cell populatins, and the latter represent edges or the relation 
between cell population --- note that edges always point from parent to 
child cell populations indicative of whether or not a cell population is a 
sub-population of another.

```{r}
# get sample meta data
head(fg_get_meta(fg))

# modify sample meta data
meta_new <- fg_get_meta(fg)
meta_new$id[1] <- "new_sample_id1"
fg <- fg_replace_meta(fg, meta_new)
```
```{r}
# get cell population meta data
gr <- fg_get_graph(fg)
head(gr$v)
head(gr$e)
```


## Feature values

The user can also extract or modify the features inside a flowGraph object. 
For adding new features, unless needed, we recommend users stick with the 
default feature generation methods that starts with `fg_feat_`.

```{r}
# get feature descriptions
fg_get_feature_desc(fg)
# get count node feature
mc <- fg_get_feature(fg, type="node", feature="count")
dim(mc)
```
```{r}
# add a new feature; 
# input matrix must contain the same row and column names as existing features;
# we recommend users stick with default feature generation methods 
# that start with fg_feat_
fg <- fg_add_feature(fg, type="node", feature="count_copy", m=mc)
fg_get_feature_desc(fg)
```
```{r}
# remove a feature; note, the count node feature cannot be removed
fg <- fg_rm_feature(fg, type="node", feature="count_copy")
fg_get_feature_desc(fg)
```


## Feature summary statistics

Once a flowGraph object is created, the user can calculate summary statistics 
for any of the features it contains.

We recommend the user use the `fg_summary` function. Its default 
summary statistic is the significance T-test along with a `byLayer` 
p-value adjustment method. The user can specify other summary statistics or 
adjustment methods by providing the name of the method or a function to 
parameters `test_custom` or `adjust_custom`.

```{r}
fg_get_summary_desc(fg)

# calculate summary statistic
fg <- fg_summary(fg, no_cores=no_cores, class="class", label1="control",
                 node_features="count", edge_features="NONE",
                 overwrite=FALSE, test_name="t", diminish=FALSE)
fg_get_summary_desc(fg)
```
```{r}
# get a summary statistic
fg_sum1 <- fg_get_summary(fg, type="node",  summary_meta=list(
    feature="count", test_name="t", 
    class="class", label1="control", label2="exp"))
names(fg_sum1)
```
```{r}
# remove a summary statistic
fg <- fg_rm_summary(fg, type="node", summary_meta=list(
    feature="count", test_name="t", 
    class="class", label1="control", label2="exp"))
fg_get_summary_desc(fg)
```
```{r}
# add a new feature summary; 
# input list must contain a 'values', 'id1', and 'id2' containing summary 
# statistic values and the sample id's compared;
# we recommend users stick with default feature generation method fg_summary
fg <- fg_add_summary(fg, type="node",  summary_meta=list(
    feature="SpecEnr", test_name="t_copy",
    class="class", label1="control", label2="exp"), p=fg_sum1)
fg_get_summary_desc(fg)
```


A summary static statistic, once obtained, is a list containing:
- `values`: a vector of p-values for each node or edge.
- `id1` and `id2`: a vector of sample id's that were compared.
- `test_fun` and `adjust_fun`: the functions used to test and adjust the 
   summary statistic.
- `m1` and `m2`: a vector that summarizes one of the sets of samples compared. 
   These are not contained inside a flowGraph object but can be calculated on 
   the spot when retreiving a summary using `fg_get_summary` by setting 
   parameter `summary_fun` to a matrix function (default: `colSums`) and not 
   `NULL`. This usually does not need to be adjusted.


# Plotting and visualizing results

All of the calculated summaries can be visualized in the form of a 
cell hierarchy plot using function `fg_plot`. The plot can also be saved as a 
PNG file if the path to this PNG file is provided as a string for its 
`path` parameter. Here, we do not save the plot, but we plot the returned 
`graph` list `gr` given by `fg_plot` that contains all the plotting columns 
using the `plot_gr` function.

```{r}
# plotting functions default to plotting node feature SpecEnr 
# labelled with mean expected/proportion (maximum 30 labels are shown for clarity)
# and only significant nodes based on the wilcox_byLayer_diminish summary statistic
# are shown.
# gr <- fg_plot(fg, p_thres=.01, show_bgedges=TRUE, # show background edges
#               node_feature="SpecEnr", edge_feature="prop",
#               test_name="t_diminish", label_max=30)
gr <- fg_plot(fg, index=1, p_thres=.01, show_bgedges=TRUE)
# plot_gr(gr)
```

While through `plot_gr`, `fg_plot` uses the `ggplot2` package to create static
plot, the user can 
also choose to plot `gr` as an interactive plot by setting the `interactive` 
parameter to `TRUE` using the `ggiraph` package.

```{r}
# interactive version in beta
plot_gr(gr, interactive=TRUE)
```

The user can also manually specify how the plot should look. The columns 
needed for plotting in `plot_gr` can be attached onto the `graph` slot of the 
`fg` the `flowGraph` object using the `ggdf` function. For more information on 
these columns, see `?ggdf`.

```{r}
gr <- fg_get_graph(fg)
gr <- ggdf(gr)

gr$v$colour <- ifelse(!grepl("[-]",gr$v$phenotype), 1, 0)
                     # "nodes with only marker conditions", "other nodes")
gr$v$label <- gr$v$phenotype
gr$v$v_ind <- gr$v$label_ind <- TRUE
gr$e$e_ind <- !grepl("[-]",gr$e$from) & !grepl("[-]",gr$e$to)

plot_gr(gr, main="Example cell hierarchy with markers A, B, C, D")
```


# Appendix

## Appendix 1: Starting from raw FCS files, a Workflow for initializing a `flowGraph` object using `Phenotypes` objects.


Other than using a cell count matrix, the user can also initialize a flowGraph 
object directly from `Phenotypes` object(s) as defined in the `flowType` 
package. Below, we show an example of how to generate `Phenotypes` objects
from raw FCS files and how that they can be used as input to initialize a 
flowGraph object.

### Preparing FCS files and corresponding marker thresholds

For each FCS file, to generate a `Phenotypes` object, the `flowType` function takes as input:
- `f`: An FCS file or `flowFrame` object from the `flowCore` package. This `flowGrame` object contains a cell by marker expression matrix in its `exprs` slot. Make sure that the cells in this matrix only contains cells that you want to analyze (e.g. live cells, lymphocytes) free of any debris or known noise.
- `thres`: A list of marker thresholds. Each element in this list is named with a marker corresponding to a column in the expression matrix. Each element contains a vector of one or more numeric values corresponding to threshold gate(s) used for that particular marker. These thresholds define whether a cell contains or does not contain a certain marker based on whether or not its (transformed) fluorescent intensity for that marker is greater or less than the given threshold value. We recommend that these thresholds be defined during manual gating of the FCS files to incorporate expert knowledge. If single value threshold gates are not available, one can define these thresholds using, for example, an extreme value of an arbitrarily shaped gate or define a threshold gate on all cells based on a consistent pattern for each marker using the `flowDensity` package. It is ideal if these threshold gate values make sense to you.

For more information, see the `flowType` package.

Below, we simulate some FCS files and their corresponding marker thresholds
as input into the `flowType` function to create our `Phenotypes` objects
to use as input into `flowGraph`.

We first define the specifications and marker thresholds `thres` 
for our FCS files.

```{r eval=FALSE}
# no_cores <- 1 #parallel::detectCores()-1 # prepare parallel backend
future::plan(future::multiprocess)

## create Phenotypes data ----------------------

# define specs for each FCS file we will artificially generate
celln <- 10000 # number of cells per FCS file
markern <- 3 # number of markers per FCS file
markers <- LETTERS[1:markern] # marker names: A, B, C

# define marker thresholds as values at the 50th percentile
cvd <- rnorm(celln,2,1)
p50 <- quantile(cvd, .5)
thres <- lapply(markers, function(x) p50)
names(thres) <- markers

# number of samples to generate
samplen <- 10
```

We then generate the FCS files `f` and their `Phenotype` objects.
We organize these `Phenotype` objects into a list `ftl`.

```{r eval=FALSE}
# generate flowType Phenotypes list
ftl <- furrr::future_map(1:samplen, function(i) {
    # make flow frame
    f <- new("flowFrame")
    f@exprs <- matrix(rnorm(celln*markern,2,1), nrow=celln)
    colnames(f@exprs) <- markers
    
    # marker indices in flow frame
    ci <- c(1:ncol(f@exprs))
    names(ci) <- colnames(f@exprs)
    
    # modify experiment samples such that ABC increases by 50%
    if (i>(samplen/2)) {
        ap <- f@exprs[,1]>thres[[1]]
        bp <- f@exprs[,2]>thres[[2]]
        cp <- f@exprs[,3]>thres[[3]]
        tm <- sum(ap & bp & cp)/2
        f@exprs <- rbind(f@exprs,
                         f@exprs[sample(which(ap & bp & cp),tm),])
    }
    
    # make flowType Phenotypes
    flowType(Frame=f, # flowFrame
              # a vector of 1:length(markers) named with marker names
             PropMarkers=ci,
             MarkerNames=colnames(f@exprs), # marker names
              # maximum number of markers each cell population should be 
              # defined with; we recommend around 6 markers, 
              # as anything more may be hard to interpret.
             MaxMarkersPerPop=markern,
             PartitionsPerMarker=2, 
              # if you have more than one threshold per marker, this would be a
              # vector the same length as the number of markers where each value
              # is 1+ the number of thresholds for the corresponding marker.
             Thresholds=thres, # thresholds list
             Methods='Thresholds', verbose=FALSE, MemLimit=60)#@CellFreqs
})
```

For each `Phenotype` object, we document their meta data into a data frame.

```{r eval=FALSE}
meta_file <- data.frame(
    id=1:samplen,
    class=append(rep("control", samplen/2), rep("exp", samplen/2)),
    stringsAsFactors=FALSE
)
```

Finally, we construct the `flowGraph` object for our FCS files.

```{r eval=FALSE}
# input: Phenotype list
fg_ <- flowGraph(ftl, class=meta_file$class, no_cores=no_cores)
# fg_ <- flowGraph(ftl, meta=meta_file, no_cores=no_cores)
```


## Appendix 2: Other options for flowGraph object initialization

The input for `flowGraph` can have the following formats

```{r eval=FALSE}
## using the constructor -----------------------

data(fg_data_pos30)

# input: Phenotype list
fg_ <- flowGraph(ftl, class=meta_file$class, no_cores=no_cores)
# fg <- flowGraph(ftl, meta=meta_file, no_cores=no_cores)

# input: Phenotype object
fg_ <- flowGraph(ftl[[1]], no_cores=no_cores)

# input: vector of load-able Phenotypes paths
fg_ <- flowGraph(fg_data_pos30$count[1,], no_cores=no_cores)

# input: matrix
fg_ <- flowGraph(fg_data_pos30$count, class=meta_file$class, no_cores=no_cores)
# fg_ <- flowGraph(fg_data_pos30$count, meta=meta_file, no_cores=no_cores)
```



### Initialize flowGraph object and split it up based on the panel a sample is analyzed on

Most of the time, if you have a collection of flow cytometry samples analyzed 
using the same set of markers, we recommend that you use option 1 and directly 
calculate all features during the initialization of the flowGraph object. 
However, there may be times when you have analyzed samples from the same 
subject on mutiple panels or marker sets and want to create multiple 
flowGraph objects, one for each panel. 

If all panels **contain the same number of markers**, you can collate them 
together into one matrix or one `Phenotypes` list, create one single 
flowGraph object for all of them, and then split them up. Note that all 
feature can be calculated initially; the only feature that must be calculated 
post split up of the flowGraph object is normalized count because it depends 
on the cell counts' behaviour between samples.

```{r eval=FALSE}
data(fg_data_pos15)
# no_cores <- 1

## create a panels column in the sample meta data indicating which panel each
## sample belongs to; also prepare the markers for each panel
meta_data <- fg_data_pos15$meta
meta_data$panel <- 1
meta_data$panel[6:15] <- 2
markers <- list(c("A1","B1","C1","D1"), c("A2","B2","C2","D2"))

## initialize flowGraph object with all samples
fg0 <- flowGraph(fg_data_pos15$count, meta=meta_data, no_cores=no_cores,
                prop=TRUE, specenr=TRUE, normalize=FALSE,
                calculate_summary=FALSE)

## split fg0 by panel and calculate normalized count on its own
fg_ <- purrr::map(unique(meta_data$panel), function(panel) {
    # extrac the samples for one panel
    fg <- fg_extract_samples(fg0, meta_data$id[meta_data$panel==panel])
    fg <- fg_feat_node_norm(fg, no_cores=no_cores, norm_path=NULL) # norm count
    marker <- markers[[panel]]
    fg <- fg_gsub_markers(fg, marker)
    fg
})

fg1 <- fg_[[1]]
fg2 <- fg_[[2]]

show(fg1)
show(fg2)
```


### Initializing a flowGraph object using `cumsumpos=TRUE`

If the data set being used, such as `fg_data_pos30`, contains more than one 
threshold for some number of markers, the user can choose to set 
`cumsumpos` to `TRUE`. If this is set to `TRUE`, all cell populations with a 
positive marker condition will have a cell count that is the sum of all 
cell population containing the same positive marker condition. 
For example, if originally $A^+$, $A^{++}$, and $A^{+++}$ had 
cell counts $20$, $30$, and $10$, then after setting `cumsumpos` to `TRUE`, 
they will have cell counts $60$, $40$, and $10$.

A note that a flowGraph object cannot switch between `cumsumpos=TRUE` and 
`cumsumpos=FALSE`, so it would need to be specified upon creation of the 
flowGraph object.

```{r eval=FALSE}
# no_cores <- 1 # number of cores to parallelize on.
data(fg_data_pos30)
fg1 <- flowGraph(fg_data_pos30$count, class=fg_data_pos30$meta$class, 
                 no_cores=no_cores,
                 prop=TRUE, specenr=TRUE, normalize=FALSE, 
                 cumsumpos=TRUE)
fg1@etc$cumsumpos

```


### Comparing SpecEnr of features other than proportions (e.g. count, cells per ml of blood)

The default SpecEnr values are created based on comparing proportions with expected proportions. Sometimes, users may want to compare other values instead, for example, counts with expected counts, cells per ml of blood with expected cells per ml of blood. While the original SpecEnr values must be calculated based on proportions, it can be converted into SpecEnr for other quantifications by changing the comparison feature (something other than proportions, in the example below, we use counts). This new SpecEnr feature can be added into the flowGraph object by simply specifying what feature (e.g. count) one wants to base the new SpecEnr off of.

```{r eval=FALSE}
fg <- fg_feat_node_specenr(fg, feature="count")
show(fg)
```



## Appendix 3: OTher useful plots

Summary statistics can also be analyzed using other plots.

### QQ plot
For example, the user can plot a static/interactive 
`ggiraph` QQ plot of a chosen summary statistic. This plots the p-values against
a uniform distribution.

```{r, message=FALSE}
data(fg_data_pos15)
fg1 <- flowGraph(fg_data_pos15$count, class=fg_data_pos15$meta$class, 
                 no_cores=no_cores)
```
```{r}
fg_get_summary_desc(fg)

fg_plot_qq(fg, type="node", index=1)
fg_plot_qq(fg, type="node", index=1, logged=TRUE)

# interactive version
fg_plot_qq(fg, type="node", index=1, interactive=TRUE)
```

### Boxplot
To understand how each p-value was obtained, the user can also plot the 
distribution of values as boxplots for a specific feature between features of different
class labels.

```{r}
fg_plot_box(fg, type="node", summary_meta=NULL, index=1, node_edge="A+")
```

### Logged p-value vs feature difference
Another useful plot is to compare the p-value and the difference between the
mean of a feature value between samples of different classes. This should
look like a volcano plot.

```{r}
fg_plot_pVSdiff(fg, type="node", summary_meta=NULL, index=1)

# interactive version
fg_plot_pVSdiff(fg, type="node", summary_meta=NULL, index=1, interactive=TRUE)
```


# System information

The following is an output of `sessionInfo()` on the system on which this 
document was compiled.

```{r}
sessionInfo()
```


# References
